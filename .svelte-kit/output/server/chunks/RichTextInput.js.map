{"version":3,"file":"RichTextInput.js","sources":["../../../../src/lib/components/common/RichTextInput.svelte"],"sourcesContent":["<script lang=\"ts\">\n\timport { marked } from 'marked';\n\timport TurndownService from 'turndown';\n\tconst turndownService = new TurndownService({\n\t\tcodeBlockStyle: 'fenced',\n\t\theadingStyle: 'atx'\n\t});\n\tturndownService.escape = (string) => string;\n\n\timport { onMount, onDestroy } from 'svelte';\n\timport { createEventDispatcher } from 'svelte';\n\tconst eventDispatch = createEventDispatcher();\n\n\timport { EditorState, Plugin, PluginKey, TextSelection } from 'prosemirror-state';\n\timport { Decoration, DecorationSet } from 'prosemirror-view';\n\n\timport { Editor } from '@tiptap/core';\n\n\timport { AIAutocompletion } from './RichTextInput/AutoCompletion.js';\n\n\timport CodeBlockLowlight from '@tiptap/extension-code-block-lowlight';\n\timport Placeholder from '@tiptap/extension-placeholder';\n\timport Highlight from '@tiptap/extension-highlight';\n\timport Typography from '@tiptap/extension-typography';\n\timport StarterKit from '@tiptap/starter-kit';\n\timport { all, createLowlight } from 'lowlight';\n\n\timport { PASTED_TEXT_CHARACTER_LIMIT } from '$lib/constants';\n\n\t// create a lowlight instance with all languages loaded\n\tconst lowlight = createLowlight(all);\n\n\texport let className = 'input-prose';\n\texport let placeholder = 'Type here...';\n\texport let value = '';\n\texport let id = '';\n\n\texport let raw = false;\n\n\texport let preserveBreaks = false;\n\texport let generateAutoCompletion: Function = async () => null;\n\texport let autocomplete = false;\n\texport let messageInput = false;\n\texport let shiftEnter = false;\n\texport let largeTextAsFile = false;\n\n\tlet element;\n\tlet editor;\n\n\tconst options = {\n\t\tthrowOnError: false\n\t};\n\n\t// Function to find the next template in the document\n\tfunction findNextTemplate(doc, from = 0) {\n\t\tconst patterns = [{ start: '{{', end: '}}' }];\n\n\t\tlet result = null;\n\n\t\tdoc.nodesBetween(from, doc.content.size, (node, pos) => {\n\t\t\tif (result) return false; // Stop if we've found a match\n\t\t\tif (node.isText) {\n\t\t\t\tconst text = node.text;\n\t\t\t\tlet index = Math.max(0, from - pos);\n\t\t\t\twhile (index < text.length) {\n\t\t\t\t\tfor (const pattern of patterns) {\n\t\t\t\t\t\tif (text.startsWith(pattern.start, index)) {\n\t\t\t\t\t\t\tconst endIndex = text.indexOf(pattern.end, index + pattern.start.length);\n\t\t\t\t\t\t\tif (endIndex !== -1) {\n\t\t\t\t\t\t\t\tresult = {\n\t\t\t\t\t\t\t\t\tfrom: pos + index,\n\t\t\t\t\t\t\t\t\tto: pos + endIndex + pattern.end.length\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\treturn false; // Stop searching\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn result;\n\t}\n\n\t// Function to select the next template in the document\n\tfunction selectNextTemplate(state, dispatch) {\n\t\tconst { doc, selection } = state;\n\t\tconst from = selection.to;\n\t\tlet template = findNextTemplate(doc, from);\n\n\t\tif (!template) {\n\t\t\t// If not found, search from the beginning\n\t\t\ttemplate = findNextTemplate(doc, 0);\n\t\t}\n\n\t\tif (template) {\n\t\t\tif (dispatch) {\n\t\t\t\tconst tr = state.tr.setSelection(TextSelection.create(doc, template.from, template.to));\n\t\t\t\tdispatch(tr);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\texport const setContent = (content) => {\n\t\teditor.commands.setContent(content);\n\t};\n\n\tconst selectTemplate = () => {\n\t\tif (value !== '') {\n\t\t\t// After updating the state, try to find and select the next template\n\t\t\tsetTimeout(() => {\n\t\t\t\tconst templateFound = selectNextTemplate(editor.view.state, editor.view.dispatch);\n\t\t\t\tif (!templateFound) {\n\t\t\t\t\t// If no template found, set cursor at the end\n\t\t\t\t\tconst endPos = editor.view.state.doc.content.size;\n\t\t\t\t\teditor.view.dispatch(\n\t\t\t\t\t\teditor.view.state.tr.setSelection(TextSelection.create(editor.view.state.doc, endPos))\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}, 0);\n\t\t}\n\t};\n\n\tonMount(async () => {\n\t\tconsole.log(value);\n\n\t\tif (preserveBreaks) {\n\t\t\tturndownService.addRule('preserveBreaks', {\n\t\t\t\tfilter: 'br', // Target <br> elements\n\t\t\t\treplacement: function (content) {\n\t\t\t\t\treturn '<br/>';\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tlet content = value;\n\n\t\tif (!raw) {\n\t\t\tasync function tryParse(value, attempts = 3, interval = 100) {\n\t\t\t\ttry {\n\t\t\t\t\t// Try parsing the value\n\t\t\t\t\treturn marked.parse(value.replaceAll(`\\n<br/>`, `<br/>`), {\n\t\t\t\t\t\tbreaks: false\n\t\t\t\t\t});\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// If no attempts remain, fallback to plain text\n\t\t\t\t\tif (attempts <= 1) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t\t// Wait for the interval, then retry\n\t\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, interval));\n\t\t\t\t\treturn tryParse(value, attempts - 1, interval); // Recursive call\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Usage example\n\t\t\tcontent = await tryParse(value);\n\t\t}\n\n\t\teditor = new Editor({\n\t\t\telement: element,\n\t\t\textensions: [\n\t\t\t\tStarterKit,\n\t\t\t\tCodeBlockLowlight.configure({\n\t\t\t\t\tlowlight\n\t\t\t\t}),\n\t\t\t\tHighlight,\n\t\t\t\tTypography,\n\t\t\t\tPlaceholder.configure({ placeholder }),\n\t\t\t\t...(autocomplete\n\t\t\t\t\t? [\n\t\t\t\t\t\t\tAIAutocompletion.configure({\n\t\t\t\t\t\t\t\tgenerateCompletion: async (text) => {\n\t\t\t\t\t\t\t\t\tif (text.trim().length === 0) {\n\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tconst suggestion = await generateAutoCompletion(text).catch(() => null);\n\t\t\t\t\t\t\t\t\tif (!suggestion || suggestion.trim().length === 0) {\n\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn suggestion;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t]\n\t\t\t\t\t: [])\n\t\t\t],\n\t\t\tcontent: content,\n\t\t\tautofocus: messageInput ? true : false,\n\t\t\tonTransaction: () => {\n\t\t\t\t// force re-render so `editor.isActive` works as expected\n\t\t\t\teditor = editor;\n\n\t\t\t\tif (!raw) {\n\t\t\t\t\tlet newValue = turndownService\n\t\t\t\t\t\t.turndown(\n\t\t\t\t\t\t\teditor\n\t\t\t\t\t\t\t\t.getHTML()\n\t\t\t\t\t\t\t\t.replace(/<p><\\/p>/g, '<br/>')\n\t\t\t\t\t\t\t\t.replace(/ {2,}/g, (m) => m.replace(/ /g, '\\u00a0'))\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.replace(/\\u00a0/g, ' ');\n\n\t\t\t\t\tif (!preserveBreaks) {\n\t\t\t\t\t\tnewValue = newValue.replace(/<br\\/>/g, '');\n\t\t\t\t\t}\n\n\t\t\t\t\tif (value !== newValue) {\n\t\t\t\t\t\tvalue = newValue;\n\n\t\t\t\t\t\t// check if the node is paragraph as well\n\t\t\t\t\t\tif (editor.isActive('paragraph')) {\n\t\t\t\t\t\t\tif (value === '') {\n\t\t\t\t\t\t\t\teditor.commands.clearContent();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvalue = editor.getHTML();\n\t\t\t\t}\n\t\t\t},\n\t\t\teditorProps: {\n\t\t\t\tattributes: { id },\n\t\t\t\thandleDOMEvents: {\n\t\t\t\t\tfocus: (view, event) => {\n\t\t\t\t\t\teventDispatch('focus', { event });\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t},\n\t\t\t\t\tkeyup: (view, event) => {\n\t\t\t\t\t\teventDispatch('keyup', { event });\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t},\n\t\t\t\t\tkeydown: (view, event) => {\n\t\t\t\t\t\tif (messageInput) {\n\t\t\t\t\t\t\t// Handle Tab Key\n\t\t\t\t\t\t\tif (event.key === 'Tab') {\n\t\t\t\t\t\t\t\tconst handled = selectNextTemplate(view.state, view.dispatch);\n\t\t\t\t\t\t\t\tif (handled) {\n\t\t\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (event.key === 'Enter') {\n\t\t\t\t\t\t\t\t// Check if the current selection is inside a structured block (like codeBlock or list)\n\t\t\t\t\t\t\t\tconst { state } = view;\n\t\t\t\t\t\t\t\tconst { $head } = state.selection;\n\n\t\t\t\t\t\t\t\t// Recursive function to check ancestors for specific node types\n\t\t\t\t\t\t\t\tfunction isInside(nodeTypes: string[]): boolean {\n\t\t\t\t\t\t\t\t\tlet currentNode = $head;\n\t\t\t\t\t\t\t\t\twhile (currentNode) {\n\t\t\t\t\t\t\t\t\t\tif (nodeTypes.includes(currentNode.parent.type.name)) {\n\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (!currentNode.depth) break; // Stop if we reach the top\n\t\t\t\t\t\t\t\t\t\tcurrentNode = state.doc.resolve(currentNode.before()); // Move to the parent node\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst isInCodeBlock = isInside(['codeBlock']);\n\t\t\t\t\t\t\t\tconst isInList = isInside(['listItem', 'bulletList', 'orderedList']);\n\t\t\t\t\t\t\t\tconst isInHeading = isInside(['heading']);\n\n\t\t\t\t\t\t\t\tif (isInCodeBlock || isInList || isInHeading) {\n\t\t\t\t\t\t\t\t\t// Let ProseMirror handle the normal Enter behavior\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Handle shift + Enter for a line break\n\t\t\t\t\t\t\tif (shiftEnter) {\n\t\t\t\t\t\t\t\tif (event.key === 'Enter' && event.shiftKey && !event.ctrlKey && !event.metaKey) {\n\t\t\t\t\t\t\t\t\teditor.commands.setHardBreak(); // Insert a hard break\n\t\t\t\t\t\t\t\t\tview.dispatch(view.state.tr.scrollIntoView()); // Move viewport to the cursor\n\t\t\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\teventDispatch('keydown', { event });\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t},\n\t\t\t\t\tpaste: (view, event) => {\n\t\t\t\t\t\tif (event.clipboardData) {\n\t\t\t\t\t\t\t// Extract plain text from clipboard and paste it without formatting\n\t\t\t\t\t\t\tconst plainText = event.clipboardData.getData('text/plain');\n\t\t\t\t\t\t\tif (plainText) {\n\t\t\t\t\t\t\t\tif (largeTextAsFile) {\n\t\t\t\t\t\t\t\t\tif (plainText.length > PASTED_TEXT_CHARACTER_LIMIT) {\n\t\t\t\t\t\t\t\t\t\t// Dispatch paste event to parent component\n\t\t\t\t\t\t\t\t\t\teventDispatch('paste', { event });\n\t\t\t\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Check if the pasted content contains image files\n\t\t\t\t\t\t\tconst hasImageFile = Array.from(event.clipboardData.files).some((file) =>\n\t\t\t\t\t\t\t\tfile.type.startsWith('image/')\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// Check for image in dataTransfer items (for cases where files are not available)\n\t\t\t\t\t\t\tconst hasImageItem = Array.from(event.clipboardData.items).some((item) =>\n\t\t\t\t\t\t\t\titem.type.startsWith('image/')\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (hasImageFile) {\n\t\t\t\t\t\t\t\t// If there's an image, dispatch the event to the parent\n\t\t\t\t\t\t\t\teventDispatch('paste', { event });\n\t\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (hasImageItem) {\n\t\t\t\t\t\t\t\t// If there's an image item, dispatch the event to the parent\n\t\t\t\t\t\t\t\teventDispatch('paste', { event });\n\t\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// For all other cases (text, formatted text, etc.), let ProseMirror handle it\n\t\t\t\t\t\tview.dispatch(view.state.tr.scrollIntoView()); // Move viewport to the cursor after pasting\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (messageInput) {\n\t\t\tselectTemplate();\n\t\t}\n\t});\n\n\tonDestroy(() => {\n\t\tif (editor) {\n\t\t\teditor.destroy();\n\t\t}\n\t});\n\n\t// Update the editor content if the external `value` changes\n\t$: if (\n\t\teditor &&\n\t\t(raw\n\t\t\t? value !== editor.getHTML()\n\t\t\t: value !==\n\t\t\t\tturndownService\n\t\t\t\t\t.turndown(\n\t\t\t\t\t\t(preserveBreaks\n\t\t\t\t\t\t\t? editor.getHTML().replace(/<p><\\/p>/g, '<br/>')\n\t\t\t\t\t\t\t: editor.getHTML()\n\t\t\t\t\t\t).replace(/ {2,}/g, (m) => m.replace(/ /g, '\\u00a0'))\n\t\t\t\t\t)\n\t\t\t\t\t.replace(/\\u00a0/g, ' '))\n\t) {\n\t\tif (raw) {\n\t\t\teditor.commands.setContent(value);\n\t\t} else {\n\t\t\tpreserveBreaks\n\t\t\t\t? editor.commands.setContent(value)\n\t\t\t\t: editor.commands.setContent(\n\t\t\t\t\t\tmarked.parse(value.replaceAll(`\\n<br/>`, `<br/>`), {\n\t\t\t\t\t\t\tbreaks: false\n\t\t\t\t\t\t})\n\t\t\t\t\t); // Update editor content\n\t\t}\n\n\t\tselectTemplate();\n\t}\n</script>\n\n<div bind:this={element} class=\"relative w-full min-w-full h-full min-h-fit {className}\" />\n"],"names":[],"mappings":";;;;;;;;;;;QAGO,kBAAsB,IAAA,gBAAA;AAAA,IAC3B,gBAAgB;AAAA,IAChB,cAAc;AAAA;AAEf,kBAAgB,SAAU,YAAW;AAIf,wBAAA;AAmBL,iBAAe,GAAG;QAExB,YAAY,cAAA,IAAA;QACZ,cAAc,eAAA,IAAA;QACd,QAAQ,GAAA,IAAA;QACR,KAAK,GAAA,IAAA;QAEL,MAAM,MAAA,IAAA;QAEN,iBAAiB,MAAA,IAAA;QACjB,yBAA+C,YAAA,KAAA,IAAA;QAC/C,eAAe,MAAA,IAAA;QACf,eAAe,MAAA,IAAA;QACf,aAAa,MAAA,IAAA;QACb,kBAAkB,MAAA,IAAA;AAEzB,MAAA;AACA,MAAA;QA2DS,aAAc,aAAA;AAC1B,WAAO,SAAS,WAAW,OAAO;AAAA;AA0OnC,YAAA,MAAA;AAAA;;;;;;;;;;;;;AAqC4E,SAAA,eAAA,iDAAA,OAAA,0CAA7D,SAAO,CAAA,CAAA;;"}