{"version":3,"file":"index5.js","sources":["../../../../src/lib/types/index.ts","../../../../src/lib/utils/index.ts"],"sourcesContent":["export type Banner = {\n\tid: string;\n\ttype: string;\n\ttitle?: string;\n\tcontent: string;\n\turl?: string;\n\tdismissible?: boolean;\n\ttimestamp: number;\n};\n\nexport enum TTS_RESPONSE_SPLIT {\n\tPUNCTUATION = 'punctuation',\n\tPARAGRAPHS = 'paragraphs',\n\tNONE = 'none'\n}\n","import { v4 as uuidv4 } from 'uuid';\nimport sha256 from 'js-sha256';\n\nimport dayjs from 'dayjs';\nimport relativeTime from 'dayjs/plugin/relativeTime';\nimport isToday from 'dayjs/plugin/isToday';\nimport isYesterday from 'dayjs/plugin/isYesterday';\nimport localizedFormat from 'dayjs/plugin/localizedFormat';\n\nimport * as excelUtils from './excelUtils';\n\ndayjs.extend(relativeTime);\ndayjs.extend(isToday);\ndayjs.extend(isYesterday);\ndayjs.extend(localizedFormat);\n\nimport { WEBUI_BASE_URL } from '$lib/constants';\nimport { TTS_RESPONSE_SPLIT } from '$lib/types';\n\n//////////////////////////\n// Helper functions\n//////////////////////////\n\nexport const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));\n\nfunction escapeRegExp(string: string): string {\n\treturn string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nexport const replaceTokens = (content, sourceIds, char, user) => {\n\tconst charToken = /{{char}}/gi;\n\tconst userToken = /{{user}}/gi;\n\tconst videoIdToken = /{{VIDEO_FILE_ID_([a-f0-9-]+)}}/gi; // Regex to capture the video ID\n\tconst htmlIdToken = /{{HTML_FILE_ID_([a-f0-9-]+)}}/gi; // Regex to capture the HTML ID\n\n\t// Replace {{char}} if char is provided\n\tif (char !== undefined && char !== null) {\n\t\tcontent = content.replace(charToken, char);\n\t}\n\n\t// Replace {{user}} if user is provided\n\tif (user !== undefined && user !== null) {\n\t\tcontent = content.replace(userToken, user);\n\t}\n\n\t// Replace video ID tags with corresponding <video> elements\n\tcontent = content.replace(videoIdToken, (match, fileId) => {\n\t\tconst videoUrl = `${WEBUI_BASE_URL}/api/v1/files/${fileId}/content`;\n\t\treturn `<video src=\"${videoUrl}\" controls></video>`;\n\t});\n\n\t// Replace HTML ID tags with corresponding HTML content\n\tcontent = content.replace(htmlIdToken, (match, fileId) => {\n\t\tconst htmlUrl = `${WEBUI_BASE_URL}/api/v1/files/${fileId}/content/html`;\n\t\treturn `<iframe src=\"${htmlUrl}\" width=\"100%\" frameborder=\"0\" onload=\"this.style.height=(this.contentWindow.document.body.scrollHeight+20)+'px';\"></iframe>`;\n\t});\n\n\t// Remove sourceIds from the content and replace them with <source_id>...</source_id>\n\tif (Array.isArray(sourceIds)) {\n\t\tsourceIds.forEach((sourceId, idx) => {\n\t\t\t// Create a token based on the exact `[sourceId]` string\n\t\t\tconst sourceToken = `\\\\[${idx}\\\\]`; // Escape special characters for RegExp\n\t\t\tconst sourceRegex = new RegExp(sourceToken, 'g'); // Match all occurrences of [sourceId]\n\n\t\t\tcontent = content.replace(sourceRegex, `<source_id data=\"${idx}\" title=\"${sourceId}\" />`);\n\t\t});\n\t}\n\n\treturn content;\n};\n\nexport const sanitizeResponseContent = (content: string) => {\n\treturn content\n\t\t.replace(/<\\|[a-z]*$/, '')\n\t\t.replace(/<\\|[a-z]+\\|$/, '')\n\t\t.replace(/<$/, '')\n\t\t.replaceAll(/<\\|[a-z]+\\|>/g, ' ')\n\t\t.replaceAll('<', '&lt;')\n\t\t.replaceAll('>', '&gt;')\n\t\t.trim();\n};\n\nexport const processResponseContent = (content: string) => {\n\treturn content.trim();\n};\n\nexport function unescapeHtml(html: string) {\n\tconst doc = new DOMParser().parseFromString(html, 'text/html');\n\treturn doc.documentElement.textContent;\n}\n\nexport const capitalizeFirstLetter = (string) => {\n\treturn string.charAt(0).toUpperCase() + string.slice(1);\n};\n\nexport const splitStream = (splitOn) => {\n\tlet buffer = '';\n\treturn new TransformStream({\n\t\ttransform(chunk, controller) {\n\t\t\tbuffer += chunk;\n\t\t\tconst parts = buffer.split(splitOn);\n\t\t\tparts.slice(0, -1).forEach((part) => controller.enqueue(part));\n\t\t\tbuffer = parts[parts.length - 1];\n\t\t},\n\t\tflush(controller) {\n\t\t\tif (buffer) controller.enqueue(buffer);\n\t\t}\n\t});\n};\n\nexport const convertMessagesToHistory = (messages) => {\n\tconst history = {\n\t\tmessages: {},\n\t\tcurrentId: null\n\t};\n\n\tlet parentMessageId = null;\n\tlet messageId = null;\n\n\tfor (const message of messages) {\n\t\tmessageId = uuidv4();\n\n\t\tif (parentMessageId !== null) {\n\t\t\thistory.messages[parentMessageId].childrenIds = [\n\t\t\t\t...history.messages[parentMessageId].childrenIds,\n\t\t\t\tmessageId\n\t\t\t];\n\t\t}\n\n\t\thistory.messages[messageId] = {\n\t\t\t...message,\n\t\t\tid: messageId,\n\t\t\tparentId: parentMessageId,\n\t\t\tchildrenIds: []\n\t\t};\n\n\t\tparentMessageId = messageId;\n\t}\n\n\thistory.currentId = messageId;\n\treturn history;\n};\n\nexport const getGravatarURL = (email) => {\n\t// Trim leading and trailing whitespace from\n\t// an email address and force all characters\n\t// to lower case\n\tconst address = String(email).trim().toLowerCase();\n\n\t// Create a SHA256 hash of the final string\n\tconst hash = sha256(address);\n\n\t// Grab the actual image URL\n\treturn `https://www.gravatar.com/avatar/${hash}`;\n};\n\nexport const canvasPixelTest = () => {\n\t// Test a 1x1 pixel to potentially identify browser/plugin fingerprint blocking or spoofing\n\t// Inspiration: https://github.com/kkapsner/CanvasBlocker/blob/master/test/detectionTest.js\n\tconst canvas = document.createElement('canvas');\n\tconst ctx = canvas.getContext('2d');\n\tcanvas.height = 1;\n\tcanvas.width = 1;\n\tconst imageData = new ImageData(canvas.width, canvas.height);\n\tconst pixelValues = imageData.data;\n\n\t// Generate RGB test data\n\tfor (let i = 0; i < imageData.data.length; i += 1) {\n\t\tif (i % 4 !== 3) {\n\t\t\tpixelValues[i] = Math.floor(256 * Math.random());\n\t\t} else {\n\t\t\tpixelValues[i] = 255;\n\t\t}\n\t}\n\n\tctx.putImageData(imageData, 0, 0);\n\tconst p = ctx.getImageData(0, 0, canvas.width, canvas.height).data;\n\n\t// Read RGB data and fail if unmatched\n\tfor (let i = 0; i < p.length; i += 1) {\n\t\tif (p[i] !== pixelValues[i]) {\n\t\t\tconsole.log(\n\t\t\t\t'canvasPixelTest: Wrong canvas pixel RGB value detected:',\n\t\t\t\tp[i],\n\t\t\t\t'at:',\n\t\t\t\ti,\n\t\t\t\t'expected:',\n\t\t\t\tpixelValues[i]\n\t\t\t);\n\t\t\tconsole.log('canvasPixelTest: Canvas blocking or spoofing is likely');\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n};\n\nexport const compressImage = async (imageUrl, maxWidth, maxHeight) => {\n\treturn new Promise((resolve, reject) => {\n\t\tconst img = new Image();\n\t\timg.onload = () => {\n\t\t\tconst canvas = document.createElement('canvas');\n\t\t\tlet width = img.width;\n\t\t\tlet height = img.height;\n\n\t\t\t// Maintain aspect ratio while resizing\n\n\t\t\tif (maxWidth && maxHeight) {\n\t\t\t\t// Resize with both dimensions defined (preserves aspect ratio)\n\n\t\t\t\tif (width <= maxWidth && height <= maxHeight) {\n\t\t\t\t\tresolve(imageUrl);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (width / height > maxWidth / maxHeight) {\n\t\t\t\t\theight = Math.round((maxWidth * height) / width);\n\t\t\t\t\twidth = maxWidth;\n\t\t\t\t} else {\n\t\t\t\t\twidth = Math.round((maxHeight * width) / height);\n\t\t\t\t\theight = maxHeight;\n\t\t\t\t}\n\t\t\t} else if (maxWidth) {\n\t\t\t\t// Only maxWidth defined\n\n\t\t\t\tif (width <= maxWidth) {\n\t\t\t\t\tresolve(imageUrl);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\theight = Math.round((maxWidth * height) / width);\n\t\t\t\twidth = maxWidth;\n\t\t\t} else if (maxHeight) {\n\t\t\t\t// Only maxHeight defined\n\n\t\t\t\tif (height <= maxHeight) {\n\t\t\t\t\tresolve(imageUrl);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\twidth = Math.round((maxHeight * width) / height);\n\t\t\t\theight = maxHeight;\n\t\t\t}\n\n\t\t\tcanvas.width = width;\n\t\t\tcanvas.height = height;\n\n\t\t\tconst context = canvas.getContext('2d');\n\t\t\tcontext.drawImage(img, 0, 0, width, height);\n\n\t\t\t// Get compressed image URL\n\t\t\tconst compressedUrl = canvas.toDataURL();\n\t\t\tresolve(compressedUrl);\n\t\t};\n\t\timg.onerror = (error) => reject(error);\n\t\timg.src = imageUrl;\n\t});\n};\nexport const generateInitialsImage = (name) => {\n\tconst canvas = document.createElement('canvas');\n\tconst ctx = canvas.getContext('2d');\n\tcanvas.width = 100;\n\tcanvas.height = 100;\n\n\tif (!canvasPixelTest()) {\n\t\tconsole.log(\n\t\t\t'generateInitialsImage: failed pixel test, fingerprint evasion is likely. Using default image.'\n\t\t);\n\t\treturn '/user.png';\n\t}\n\n\tctx.fillStyle = '#F39C12';\n\tctx.fillRect(0, 0, canvas.width, canvas.height);\n\n\tctx.fillStyle = '#FFFFFF';\n\tctx.font = '40px Helvetica';\n\tctx.textAlign = 'center';\n\tctx.textBaseline = 'middle';\n\n\tconst sanitizedName = name.trim();\n\tconst initials =\n\t\tsanitizedName.length > 0\n\t\t\t? sanitizedName[0] +\n\t\t\t\t(sanitizedName.split(' ').length > 1\n\t\t\t\t\t? sanitizedName[sanitizedName.lastIndexOf(' ') + 1]\n\t\t\t\t\t: '')\n\t\t\t: '';\n\n\tctx.fillText(initials.toUpperCase(), canvas.width / 2, canvas.height / 2);\n\n\treturn canvas.toDataURL();\n};\n\nexport const formatDate = (inputDate) => {\n\tconst date = dayjs(inputDate);\n\tconst now = dayjs();\n\n\tif (date.isToday()) {\n\t\treturn `Today at ${date.format('LT')}`;\n\t} else if (date.isYesterday()) {\n\t\treturn `Yesterday at ${date.format('LT')}`;\n\t} else {\n\t\treturn `${date.format('L')} at ${date.format('LT')}`;\n\t}\n};\n\nexport const copyToClipboard = async (text) => {\n\tlet result = false;\n\tif (!navigator.clipboard) {\n\t\tconst textArea = document.createElement('textarea');\n\t\ttextArea.value = text;\n\n\t\t// Avoid scrolling to bottom\n\t\ttextArea.style.top = '0';\n\t\ttextArea.style.left = '0';\n\t\ttextArea.style.position = 'fixed';\n\n\t\tdocument.body.appendChild(textArea);\n\t\ttextArea.focus();\n\t\ttextArea.select();\n\n\t\ttry {\n\t\t\tconst successful = document.execCommand('copy');\n\t\t\tconst msg = successful ? 'successful' : 'unsuccessful';\n\t\t\tconsole.log('Fallback: Copying text command was ' + msg);\n\t\t\tresult = true;\n\t\t} catch (err) {\n\t\t\tconsole.error('Fallback: Oops, unable to copy', err);\n\t\t}\n\n\t\tdocument.body.removeChild(textArea);\n\t\treturn result;\n\t}\n\n\tresult = await navigator.clipboard\n\t\t.writeText(text)\n\t\t.then(() => {\n\t\t\tconsole.log('Async: Copying to clipboard was successful!');\n\t\t\treturn true;\n\t\t})\n\t\t.catch((error) => {\n\t\t\tconsole.error('Async: Could not copy text: ', error);\n\t\t\treturn false;\n\t\t});\n\n\treturn result;\n};\n\nexport const compareVersion = (latest, current) => {\n\treturn current === '0.0.0'\n\t\t? false\n\t\t: current.localeCompare(latest, undefined, {\n\t\t\t\tnumeric: true,\n\t\t\t\tsensitivity: 'case',\n\t\t\t\tcaseFirst: 'upper'\n\t\t\t}) < 0;\n};\n\nexport const findWordIndices = (text) => {\n\tconst regex = /\\[([^\\]]+)\\]/g;\n\tconst matches = [];\n\tlet match;\n\n\twhile ((match = regex.exec(text)) !== null) {\n\t\tmatches.push({\n\t\t\tword: match[1],\n\t\t\tstartIndex: match.index,\n\t\t\tendIndex: regex.lastIndex - 1\n\t\t});\n\t}\n\n\treturn matches;\n};\n\nexport const removeLastWordFromString = (inputString, wordString) => {\n\tconsole.log('inputString', inputString);\n\t// Split the string by newline characters to handle lines separately\n\tconst lines = inputString.split('\\n');\n\n\t// Take the last line to operate only on it\n\tconst lastLine = lines.pop();\n\n\t// Split the last line into an array of words\n\tconst words = lastLine.split(' ');\n\n\t// Conditional to check for the last word removal\n\tif (words.at(-1) === wordString || (wordString === '' && words.at(-1) === '\\\\#')) {\n\t\twords.pop(); // Remove last word if condition is satisfied\n\t}\n\n\t// Join the remaining words back into a string and handle space correctly\n\tlet updatedLastLine = words.join(' ');\n\n\t// Add a trailing space to the updated last line if there are still words\n\tif (updatedLastLine !== '') {\n\t\tupdatedLastLine += ' ';\n\t}\n\n\t// Combine the lines together again, placing the updated last line back in\n\tconst resultString = [...lines, updatedLastLine].join('\\n');\n\n\t// Return the final string\n\tconsole.log('resultString', resultString);\n\n\treturn resultString;\n};\n\nexport const removeFirstHashWord = (inputString) => {\n\t// Split the string into an array of words\n\tconst words = inputString.split(' ');\n\n\t// Find the index of the first word that starts with #\n\tconst index = words.findIndex((word) => word.startsWith('#'));\n\n\t// Remove the first word with #\n\tif (index !== -1) {\n\t\twords.splice(index, 1);\n\t}\n\n\t// Join the remaining words back into a string\n\tconst resultString = words.join(' ');\n\n\treturn resultString;\n};\n\nexport const transformFileName = (fileName) => {\n\t// Convert to lowercase\n\tconst lowerCaseFileName = fileName.toLowerCase();\n\n\t// Remove special characters using regular expression\n\tconst sanitizedFileName = lowerCaseFileName.replace(/[^\\w\\s]/g, '');\n\n\t// Replace spaces with dashes\n\tconst finalFileName = sanitizedFileName.replace(/\\s+/g, '-');\n\n\treturn finalFileName;\n};\n\nexport const calculateSHA256 = async (file) => {\n\t// Create a FileReader to read the file asynchronously\n\tconst reader = new FileReader();\n\n\t// Define a promise to handle the file reading\n\tconst readFile = new Promise((resolve, reject) => {\n\t\treader.onload = () => resolve(reader.result);\n\t\treader.onerror = reject;\n\t});\n\n\t// Read the file as an ArrayBuffer\n\treader.readAsArrayBuffer(file);\n\n\ttry {\n\t\t// Wait for the FileReader to finish reading the file\n\t\tconst buffer = await readFile;\n\n\t\t// Convert the ArrayBuffer to a Uint8Array\n\t\tconst uint8Array = new Uint8Array(buffer);\n\n\t\t// Calculate the SHA-256 hash using Web Crypto API\n\t\tconst hashBuffer = await crypto.subtle.digest('SHA-256', uint8Array);\n\n\t\t// Convert the hash to a hexadecimal string\n\t\tconst hashArray = Array.from(new Uint8Array(hashBuffer));\n\t\tconst hashHex = hashArray.map((byte) => byte.toString(16).padStart(2, '0')).join('');\n\n\t\treturn `${hashHex}`;\n\t} catch (error) {\n\t\tconsole.error('Error calculating SHA-256 hash:', error);\n\t\tthrow error;\n\t}\n};\n\nexport const getImportOrigin = (_chats) => {\n\t// Check what external service chat imports are from\n\tif ('mapping' in _chats[0]) {\n\t\treturn 'openai';\n\t}\n\treturn 'webui';\n};\n\nexport const getUserPosition = async (raw = false) => {\n\t// Get the user's location using the Geolocation API\n\tconst position = await new Promise((resolve, reject) => {\n\t\tnavigator.geolocation.getCurrentPosition(resolve, reject);\n\t}).catch((error) => {\n\t\tconsole.error('Error getting user location:', error);\n\t\tthrow error;\n\t});\n\n\tif (!position) {\n\t\treturn 'Location not available';\n\t}\n\n\t// Extract the latitude and longitude from the position\n\tconst { latitude, longitude } = position.coords;\n\n\tif (raw) {\n\t\treturn { latitude, longitude };\n\t} else {\n\t\treturn `${latitude.toFixed(3)}, ${longitude.toFixed(3)} (lat, long)`;\n\t}\n};\n\nconst convertOpenAIMessages = (convo) => {\n\t// Parse OpenAI chat messages and create chat dictionary for creating new chats\n\tconst mapping = convo['mapping'];\n\tconst messages = [];\n\tlet currentId = '';\n\tlet lastId = null;\n\n\tfor (const message_id in mapping) {\n\t\tconst message = mapping[message_id];\n\t\tcurrentId = message_id;\n\t\ttry {\n\t\t\tif (\n\t\t\t\tmessages.length == 0 &&\n\t\t\t\t(message['message'] == null ||\n\t\t\t\t\t(message['message']['content']['parts']?.[0] == '' &&\n\t\t\t\t\t\tmessage['message']['content']['text'] == null))\n\t\t\t) {\n\t\t\t\t// Skip chat messages with no content\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tconst new_chat = {\n\t\t\t\t\tid: message_id,\n\t\t\t\t\tparentId: lastId,\n\t\t\t\t\tchildrenIds: message['children'] || [],\n\t\t\t\t\trole: message['message']?.['author']?.['role'] !== 'user' ? 'assistant' : 'user',\n\t\t\t\t\tcontent:\n\t\t\t\t\t\tmessage['message']?.['content']?.['parts']?.[0] ||\n\t\t\t\t\t\tmessage['message']?.['content']?.['text'] ||\n\t\t\t\t\t\t'',\n\t\t\t\t\tmodel: 'gpt-3.5-turbo',\n\t\t\t\t\tdone: true,\n\t\t\t\t\tcontext: null\n\t\t\t\t};\n\t\t\t\tmessages.push(new_chat);\n\t\t\t\tlastId = currentId;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.log('Error with', message, '\\nError:', error);\n\t\t}\n\t}\n\n\tconst history: Record<PropertyKey, (typeof messages)[number]> = {};\n\tmessages.forEach((obj) => (history[obj.id] = obj));\n\n\tconst chat = {\n\t\thistory: {\n\t\t\tcurrentId: currentId,\n\t\t\tmessages: history // Need to convert this to not a list and instead a json object\n\t\t},\n\t\tmodels: ['gpt-3.5-turbo'],\n\t\tmessages: messages,\n\t\toptions: {},\n\t\ttimestamp: convo['create_time'],\n\t\ttitle: convo['title'] ?? 'New Chat'\n\t};\n\treturn chat;\n};\n\nconst validateChat = (chat) => {\n\t// Because ChatGPT sometimes has features we can't use like DALL-E or might have corrupted messages, need to validate\n\tconst messages = chat.messages;\n\n\t// Check if messages array is empty\n\tif (messages.length === 0) {\n\t\treturn false;\n\t}\n\n\t// Last message's children should be an empty array\n\tconst lastMessage = messages[messages.length - 1];\n\tif (lastMessage.childrenIds.length !== 0) {\n\t\treturn false;\n\t}\n\n\t// First message's parent should be null\n\tconst firstMessage = messages[0];\n\tif (firstMessage.parentId !== null) {\n\t\treturn false;\n\t}\n\n\t// Every message's content should be a string\n\tfor (const message of messages) {\n\t\tif (typeof message.content !== 'string') {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n};\n\nexport const convertOpenAIChats = (_chats) => {\n\t// Create a list of dictionaries with each conversation from import\n\tconst chats = [];\n\tlet failed = 0;\n\tfor (const convo of _chats) {\n\t\tconst chat = convertOpenAIMessages(convo);\n\n\t\tif (validateChat(chat)) {\n\t\t\tchats.push({\n\t\t\t\tid: convo['id'],\n\t\t\t\tuser_id: '',\n\t\t\t\ttitle: convo['title'],\n\t\t\t\tchat: chat,\n\t\t\t\ttimestamp: convo['timestamp']\n\t\t\t});\n\t\t} else {\n\t\t\tfailed++;\n\t\t}\n\t}\n\tconsole.log(failed, 'Conversations could not be imported');\n\treturn chats;\n};\n\nexport const isValidHttpUrl = (string: string) => {\n\tlet url;\n\n\ttry {\n\t\turl = new URL(string);\n\t} catch (_) {\n\t\treturn false;\n\t}\n\n\treturn url.protocol === 'http:' || url.protocol === 'https:';\n};\n\nexport const removeEmojis = (str: string) => {\n\t// Regular expression to match emojis\n\tconst emojiRegex = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|\\uD83C[\\uDC00-\\uDFFF]|\\uD83D[\\uDC00-\\uDE4F]/g;\n\n\t// Replace emojis with an empty string\n\treturn str.replace(emojiRegex, '');\n};\n\nexport const removeFormattings = (str: string) => {\n\treturn (\n\t\tstr\n\t\t\t// Block elements (remove completely)\n\t\t\t.replace(/(```[\\s\\S]*?```)/g, '') // Code blocks\n\t\t\t.replace(/^\\|.*\\|$/gm, '') // Tables\n\t\t\t// Inline elements (preserve content)\n\t\t\t.replace(/(?:\\*\\*|__)(.*?)(?:\\*\\*|__)/g, '$1') // Bold\n\t\t\t.replace(/(?:[*_])(.*?)(?:[*_])/g, '$1') // Italic\n\t\t\t.replace(/~~(.*?)~~/g, '$1') // Strikethrough\n\t\t\t.replace(/`([^`]+)`/g, '$1') // Inline code\n\n\t\t\t// Links and images\n\t\t\t.replace(/!?\\[([^\\]]*)\\](?:\\([^)]+\\)|\\[[^\\]]*\\])/g, '$1') // Links & images\n\t\t\t.replace(/^\\[[^\\]]+\\]:\\s*.*$/gm, '') // Reference definitions\n\n\t\t\t// Block formatting\n\t\t\t.replace(/^#{1,6}\\s+/gm, '') // Headers\n\t\t\t.replace(/^\\s*[-*+]\\s+/gm, '') // Lists\n\t\t\t.replace(/^\\s*(?:\\d+\\.)\\s+/gm, '') // Numbered lists\n\t\t\t.replace(/^\\s*>[> ]*/gm, '') // Blockquotes\n\t\t\t.replace(/^\\s*:\\s+/gm, '') // Definition lists\n\n\t\t\t// Cleanup\n\t\t\t.replace(/\\[\\^[^\\]]*\\]/g, '') // Footnotes\n\t\t\t.replace(/[-*_~]/g, '') // Remaining markers\n\t\t\t.replace(/\\n{2,}/g, '\\n')\n\t); // Multiple newlines\n};\n\nexport const cleanText = (content: string) => {\n\treturn removeFormattings(removeEmojis(content.trim()));\n};\n\nexport const removeDetails = (content, types) => {\n\tfor (const type of types) {\n\t\tcontent = content.replace(\n\t\t\tnew RegExp(`<details\\\\s+type=\"${type}\"[^>]*>.*?<\\\\/details>`, 'gis'),\n\t\t\t''\n\t\t);\n\t}\n\n\treturn content;\n};\n\n// This regular expression matches code blocks marked by triple backticks\nconst codeBlockRegex = /```[\\s\\S]*?```/g;\n\nexport const extractSentences = (text: string) => {\n\tconst codeBlocks: string[] = [];\n\tlet index = 0;\n\n\t// Temporarily replace code blocks with placeholders and store the blocks separately\n\ttext = text.replace(codeBlockRegex, (match) => {\n\t\tconst placeholder = `\\u0000${index}\\u0000`; // Use a unique placeholder\n\t\tcodeBlocks[index++] = match;\n\t\treturn placeholder;\n\t});\n\n\t// Split the modified text into sentences based on common punctuation marks, avoiding these blocks\n\tlet sentences = text.split(/(?<=[.!?])\\s+/);\n\n\t// Restore code blocks and process sentences\n\tsentences = sentences.map((sentence) => {\n\t\t// Check if the sentence includes a placeholder for a code block\n\t\treturn sentence.replace(/\\u0000(\\d+)\\u0000/g, (_, idx) => codeBlocks[idx]);\n\t});\n\n\treturn sentences.map(cleanText).filter(Boolean);\n};\n\nexport const extractParagraphsForAudio = (text: string) => {\n\tconst codeBlocks: string[] = [];\n\tlet index = 0;\n\n\t// Temporarily replace code blocks with placeholders and store the blocks separately\n\ttext = text.replace(codeBlockRegex, (match) => {\n\t\tconst placeholder = `\\u0000${index}\\u0000`; // Use a unique placeholder\n\t\tcodeBlocks[index++] = match;\n\t\treturn placeholder;\n\t});\n\n\t// Split the modified text into paragraphs based on newlines, avoiding these blocks\n\tlet paragraphs = text.split(/\\n+/);\n\n\t// Restore code blocks and process paragraphs\n\tparagraphs = paragraphs.map((paragraph) => {\n\t\t// Check if the paragraph includes a placeholder for a code block\n\t\treturn paragraph.replace(/\\u0000(\\d+)\\u0000/g, (_, idx) => codeBlocks[idx]);\n\t});\n\n\treturn paragraphs.map(cleanText).filter(Boolean);\n};\n\nexport const extractSentencesForAudio = (text: string) => {\n\treturn extractSentences(text).reduce((mergedTexts, currentText) => {\n\t\tconst lastIndex = mergedTexts.length - 1;\n\t\tif (lastIndex >= 0) {\n\t\t\tconst previousText = mergedTexts[lastIndex];\n\t\t\tconst wordCount = previousText.split(/\\s+/).length;\n\t\t\tconst charCount = previousText.length;\n\t\t\tif (wordCount < 4 || charCount < 50) {\n\t\t\t\tmergedTexts[lastIndex] = previousText + ' ' + currentText;\n\t\t\t} else {\n\t\t\t\tmergedTexts.push(currentText);\n\t\t\t}\n\t\t} else {\n\t\t\tmergedTexts.push(currentText);\n\t\t}\n\t\treturn mergedTexts;\n\t}, [] as string[]);\n};\n\nexport const getMessageContentParts = (content: string, split_on: string = 'punctuation') => {\n\tcontent = removeDetails(content, ['reasoning', 'code_interpreter']);\n\tconst messageContentParts: string[] = [];\n\n\tswitch (split_on) {\n\t\tdefault:\n\t\tcase TTS_RESPONSE_SPLIT.PUNCTUATION:\n\t\t\tmessageContentParts.push(...extractSentencesForAudio(content));\n\t\t\tbreak;\n\t\tcase TTS_RESPONSE_SPLIT.PARAGRAPHS:\n\t\t\tmessageContentParts.push(...extractParagraphsForAudio(content));\n\t\t\tbreak;\n\t\tcase TTS_RESPONSE_SPLIT.NONE:\n\t\t\tmessageContentParts.push(cleanText(content));\n\t\t\tbreak;\n\t}\n\n\treturn messageContentParts;\n};\n\nexport const blobToFile = (blob, fileName) => {\n\t// Create a new File object from the Blob\n\tconst file = new File([blob], fileName, { type: blob.type });\n\treturn file;\n};\n\nexport const getPromptVariables = (user_name, user_location) => {\n\treturn {\n\t\t'{{USER_NAME}}': user_name,\n\t\t'{{USER_LOCATION}}': user_location || 'Unknown',\n\t\t'{{CURRENT_DATETIME}}': getCurrentDateTime(),\n\t\t'{{CURRENT_DATE}}': getFormattedDate(),\n\t\t'{{CURRENT_TIME}}': getFormattedTime(),\n\t\t'{{CURRENT_WEEKDAY}}': getWeekday(),\n\t\t'{{CURRENT_TIMEZONE}}': getUserTimezone(),\n\t\t'{{USER_LANGUAGE}}': localStorage.getItem('locale') || 'en-US'\n\t};\n};\n\n/**\n * @param {string} template - The template string containing placeholders.\n * @returns {string} The template string with the placeholders replaced by the prompt.\n */\nexport const promptTemplate = (\n\ttemplate: string,\n\tuser_name?: string,\n\tuser_location?: string\n): string => {\n\t// Get the current date\n\tconst currentDate = new Date();\n\n\t// Format the date to YYYY-MM-DD\n\tconst formattedDate =\n\t\tcurrentDate.getFullYear() +\n\t\t'-' +\n\t\tString(currentDate.getMonth() + 1).padStart(2, '0') +\n\t\t'-' +\n\t\tString(currentDate.getDate()).padStart(2, '0');\n\n\t// Format the time to HH:MM:SS AM/PM\n\tconst currentTime = currentDate.toLocaleTimeString('en-US', {\n\t\thour: 'numeric',\n\t\tminute: 'numeric',\n\t\tsecond: 'numeric',\n\t\thour12: true\n\t});\n\n\t// Get the current weekday\n\tconst currentWeekday = getWeekday();\n\n\t// Get the user's timezone\n\tconst currentTimezone = getUserTimezone();\n\n\t// Get the user's language\n\tconst userLanguage = localStorage.getItem('locale') || 'en-US';\n\n\t// Replace {{CURRENT_DATETIME}} in the template with the formatted datetime\n\ttemplate = template.replace('{{CURRENT_DATETIME}}', `${formattedDate} ${currentTime}`);\n\n\t// Replace {{CURRENT_DATE}} in the template with the formatted date\n\ttemplate = template.replace('{{CURRENT_DATE}}', formattedDate);\n\n\t// Replace {{CURRENT_TIME}} in the template with the formatted time\n\ttemplate = template.replace('{{CURRENT_TIME}}', currentTime);\n\n\t// Replace {{CURRENT_WEEKDAY}} in the template with the current weekday\n\ttemplate = template.replace('{{CURRENT_WEEKDAY}}', currentWeekday);\n\n\t// Replace {{CURRENT_TIMEZONE}} in the template with the user's timezone\n\ttemplate = template.replace('{{CURRENT_TIMEZONE}}', currentTimezone);\n\n\t// Replace {{USER_LANGUAGE}} in the template with the user's language\n\ttemplate = template.replace('{{USER_LANGUAGE}}', userLanguage);\n\n\tif (user_name) {\n\t\t// Replace {{USER_NAME}} in the template with the user's name\n\t\ttemplate = template.replace('{{USER_NAME}}', user_name);\n\t}\n\n\tif (user_location) {\n\t\t// Replace {{USER_LOCATION}} in the template with the current location\n\t\ttemplate = template.replace('{{USER_LOCATION}}', user_location);\n\t} else {\n\t\t// Replace {{USER_LOCATION}} in the template with 'Unknown' if no location is provided\n\t\ttemplate = template.replace('{{USER_LOCATION}}', 'LOCATION_UNKNOWN');\n\t}\n\n\treturn template;\n};\n\n/**\n * This function is used to replace placeholders in a template string with the provided prompt.\n * The placeholders can be in the following formats:\n * - `{{prompt}}`: This will be replaced with the entire prompt.\n * - `{{prompt:start:<length>}}`: This will be replaced with the first <length> characters of the prompt.\n * - `{{prompt:end:<length>}}`: This will be replaced with the last <length> characters of the prompt.\n * - `{{prompt:middletruncate:<length>}}`: This will be replaced with the prompt truncated to <length> characters, with '...' in the middle.\n *\n * @param {string} template - The template string containing placeholders.\n * @param {string} prompt - The string to replace the placeholders with.\n * @returns {string} The template string with the placeholders replaced by the prompt.\n */\nexport const titleGenerationTemplate = (template: string, prompt: string): string => {\n\ttemplate = template.replace(\n\t\t/{{prompt}}|{{prompt:start:(\\d+)}}|{{prompt:end:(\\d+)}}|{{prompt:middletruncate:(\\d+)}}/g,\n\t\t(match, startLength, endLength, middleLength) => {\n\t\t\tif (match === '{{prompt}}') {\n\t\t\t\treturn prompt;\n\t\t\t} else if (match.startsWith('{{prompt:start:')) {\n\t\t\t\treturn prompt.substring(0, startLength);\n\t\t\t} else if (match.startsWith('{{prompt:end:')) {\n\t\t\t\treturn prompt.slice(-endLength);\n\t\t\t} else if (match.startsWith('{{prompt:middletruncate:')) {\n\t\t\t\tif (prompt.length <= middleLength) {\n\t\t\t\t\treturn prompt;\n\t\t\t\t}\n\t\t\t\tconst start = prompt.slice(0, Math.ceil(middleLength / 2));\n\t\t\t\tconst end = prompt.slice(-Math.floor(middleLength / 2));\n\t\t\t\treturn `${start}...${end}`;\n\t\t\t}\n\t\t\treturn '';\n\t\t}\n\t);\n\n\ttemplate = promptTemplate(template);\n\n\treturn template;\n};\n\nexport const approximateToHumanReadable = (nanoseconds: number) => {\n\tconst seconds = Math.floor((nanoseconds / 1e9) % 60);\n\tconst minutes = Math.floor((nanoseconds / 6e10) % 60);\n\tconst hours = Math.floor((nanoseconds / 3.6e12) % 24);\n\n\tconst results: string[] = [];\n\n\tif (seconds >= 0) {\n\t\tresults.push(`${seconds}s`);\n\t}\n\n\tif (minutes > 0) {\n\t\tresults.push(`${minutes}m`);\n\t}\n\n\tif (hours > 0) {\n\t\tresults.push(`${hours}h`);\n\t}\n\n\treturn results.reverse().join(' ');\n};\n\nexport const getTimeRange = (timestamp) => {\n\tconst now = new Date();\n\tconst date = new Date(timestamp * 1000); // Convert Unix timestamp to milliseconds\n\n\t// Calculate the difference in milliseconds\n\tconst diffTime = now.getTime() - date.getTime();\n\tconst diffDays = diffTime / (1000 * 3600 * 24);\n\n\tconst nowDate = now.getDate();\n\tconst nowMonth = now.getMonth();\n\tconst nowYear = now.getFullYear();\n\n\tconst dateDate = date.getDate();\n\tconst dateMonth = date.getMonth();\n\tconst dateYear = date.getFullYear();\n\n\tif (nowYear === dateYear && nowMonth === dateMonth && nowDate === dateDate) {\n\t\treturn 'Today';\n\t} else if (nowYear === dateYear && nowMonth === dateMonth && nowDate - dateDate === 1) {\n\t\treturn 'Yesterday';\n\t} else if (diffDays <= 7) {\n\t\treturn 'Previous 7 days';\n\t} else if (diffDays <= 30) {\n\t\treturn 'Previous 30 days';\n\t} else if (nowYear === dateYear) {\n\t\treturn date.toLocaleString('default', { month: 'long' });\n\t} else {\n\t\treturn date.getFullYear().toString();\n\t}\n};\n\n/**\n * Extract frontmatter as a dictionary from the specified content string.\n * @param content {string} - The content string with potential frontmatter.\n * @returns {Object} - The extracted frontmatter as a dictionary.\n */\nexport const extractFrontmatter = (content) => {\n\tconst frontmatter = {};\n\tlet frontmatterStarted = false;\n\tlet frontmatterEnded = false;\n\tconst frontmatterPattern = /^\\s*([a-z_]+):\\s*(.*)\\s*$/i;\n\n\t// Split content into lines\n\tconst lines = content.split('\\n');\n\n\t// Check if the content starts with triple quotes\n\tif (lines[0].trim() !== '\"\"\"') {\n\t\treturn {};\n\t}\n\n\tfrontmatterStarted = true;\n\n\tfor (let i = 1; i < lines.length; i++) {\n\t\tconst line = lines[i];\n\n\t\tif (line.includes('\"\"\"')) {\n\t\t\tif (frontmatterStarted) {\n\t\t\t\tfrontmatterEnded = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (frontmatterStarted && !frontmatterEnded) {\n\t\t\tconst match = frontmatterPattern.exec(line);\n\t\t\tif (match) {\n\t\t\t\tconst [, key, value] = match;\n\t\t\t\tfrontmatter[key.trim()] = value.trim();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn frontmatter;\n};\n\n// Function to determine the best matching language\nexport const bestMatchingLanguage = (supportedLanguages, preferredLanguages, defaultLocale) => {\n\tconst languages = supportedLanguages.map((lang) => lang.code);\n\n\tconst match = preferredLanguages\n\t\t.map((prefLang) => languages.find((lang) => lang.startsWith(prefLang)))\n\t\t.find(Boolean);\n\n\treturn match || defaultLocale;\n};\n\n// Get the date in the format YYYY-MM-DD\nexport const getFormattedDate = () => {\n\tconst date = new Date();\n\tconst year = date.getFullYear();\n\tconst month = String(date.getMonth() + 1).padStart(2, '0');\n\tconst day = String(date.getDate()).padStart(2, '0');\n\treturn `${year}-${month}-${day}`;\n};\n\n// Get the time in the format HH:MM:SS\nexport const getFormattedTime = () => {\n\tconst date = new Date();\n\treturn date.toTimeString().split(' ')[0];\n};\n\n// Get the current date and time in the format YYYY-MM-DD HH:MM:SS\nexport const getCurrentDateTime = () => {\n\treturn `${getFormattedDate()} ${getFormattedTime()}`;\n};\n\n// Get the user's timezone\nexport const getUserTimezone = () => {\n\treturn Intl.DateTimeFormat().resolvedOptions().timeZone;\n};\n\n// Get the weekday\nexport const getWeekday = () => {\n\tconst date = new Date();\n\tconst weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n\treturn weekdays[date.getDay()];\n};\n\nexport const createMessagesList = (history, messageId) => {\n\tif (messageId === null) {\n\t\treturn [];\n\t}\n\n\tconst message = history.messages[messageId];\n\tif (message?.parentId) {\n\t\treturn [...createMessagesList(history, message.parentId), message];\n\t} else {\n\t\treturn [message];\n\t}\n};\n\nexport const formatFileSize = (size) => {\n\tif (size == null) return 'Unknown size';\n\tif (typeof size !== 'number' || size < 0) return 'Invalid size';\n\tif (size === 0) return '0 B';\n\tconst units = ['B', 'KB', 'MB', 'GB', 'TB'];\n\tlet unitIndex = 0;\n\n\twhile (size >= 1024 && unitIndex < units.length - 1) {\n\t\tsize /= 1024;\n\t\tunitIndex++;\n\t}\n\treturn `${size.toFixed(1)} ${units[unitIndex]}`;\n};\n\nexport const getLineCount = (text) => {\n\tconsole.log(typeof text);\n\treturn text ? text.split('\\n').length : 0;\n};\n\nexport { readExcelFile, downloadExcel, updateCell, addSheet, csvToExcel } from './excelUtils';"],"names":["TTS_RESPONSE_SPLIT","uuidv4"],"mappings":"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"}