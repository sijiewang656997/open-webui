{"version":3,"file":"index7.js","sources":["../../../../src/lib/apis/openai/index.ts","../../../../src/lib/apis/index.ts"],"sourcesContent":["import { OPENAI_API_BASE_URL, WEBUI_API_BASE_URL, WEBUI_BASE_URL } from '$lib/constants';\n\nexport const getOpenAIConfig = async (token: string = '') => {\n\tlet error = null;\n\n\tconst res = await fetch(`${OPENAI_API_BASE_URL}/config`, {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t} else {\n\t\t\t\terror = 'Server connection failed';\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\ntype OpenAIConfig = {\n\tENABLE_OPENAI_API: boolean;\n\tOPENAI_API_BASE_URLS: string[];\n\tOPENAI_API_KEYS: string[];\n\tOPENAI_API_CONFIGS: object;\n};\n\nexport const updateOpenAIConfig = async (token: string = '', config: OpenAIConfig) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${OPENAI_API_BASE_URL}/config/update`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\t...config\n\t\t})\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t} else {\n\t\t\t\terror = 'Server connection failed';\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const getOpenAIUrls = async (token: string = '') => {\n\tlet error = null;\n\n\tconst res = await fetch(`${OPENAI_API_BASE_URL}/urls`, {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t} else {\n\t\t\t\terror = 'Server connection failed';\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res.OPENAI_API_BASE_URLS;\n};\n\nexport const updateOpenAIUrls = async (token: string = '', urls: string[]) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${OPENAI_API_BASE_URL}/urls/update`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\turls: urls\n\t\t})\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t} else {\n\t\t\t\terror = 'Server connection failed';\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res.OPENAI_API_BASE_URLS;\n};\n\nexport const getOpenAIKeys = async (token: string = '') => {\n\tlet error = null;\n\n\tconst res = await fetch(`${OPENAI_API_BASE_URL}/keys`, {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t} else {\n\t\t\t\terror = 'Server connection failed';\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res.OPENAI_API_KEYS;\n};\n\nexport const updateOpenAIKeys = async (token: string = '', keys: string[]) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${OPENAI_API_BASE_URL}/keys/update`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\tkeys: keys\n\t\t})\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t} else {\n\t\t\t\terror = 'Server connection failed';\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res.OPENAI_API_KEYS;\n};\n\nexport const getOpenAIModelsDirect = async (url: string, key: string) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${url}/models`, {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(key && { authorization: `Bearer ${key}` })\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\terror = `OpenAI: ${err?.error?.message ?? 'Network Problem'}`;\n\t\t\treturn [];\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const getOpenAIModels = async (token: string, urlIdx?: number) => {\n\tlet error = null;\n\n\tconst res = await fetch(\n\t\t`${OPENAI_API_BASE_URL}/models${typeof urlIdx === 'number' ? `/${urlIdx}` : ''}`,\n\t\t{\n\t\t\tmethod: 'GET',\n\t\t\theaders: {\n\t\t\t\tAccept: 'application/json',\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t\t}\n\t\t}\n\t)\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\terror = `OpenAI: ${err?.error?.message ?? 'Network Problem'}`;\n\t\t\treturn [];\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const verifyOpenAIConnection = async (\n\ttoken: string = '',\n\turl: string = 'https://api.openai.com/v1',\n\tkey: string = '',\n\tdirect: boolean = false\n) => {\n\tif (!url) {\n\t\tthrow 'OpenAI: URL is required';\n\t}\n\n\tlet error = null;\n\tlet res = null;\n\n\tif (direct) {\n\t\tres = await fetch(`${url}/models`, {\n\t\t\tmethod: 'GET',\n\t\t\theaders: {\n\t\t\t\tAccept: 'application/json',\n\t\t\t\tAuthorization: `Bearer ${key}`,\n\t\t\t\t'Content-Type': 'application/json'\n\t\t\t}\n\t\t})\n\t\t\t.then(async (res) => {\n\t\t\t\tif (!res.ok) throw await res.json();\n\t\t\t\treturn res.json();\n\t\t\t})\n\t\t\t.catch((err) => {\n\t\t\t\terror = `OpenAI: ${err?.error?.message ?? 'Network Problem'}`;\n\t\t\t\treturn [];\n\t\t\t});\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\t} else {\n\t\tres = await fetch(`${OPENAI_API_BASE_URL}/verify`, {\n\t\t\tmethod: 'POST',\n\t\t\theaders: {\n\t\t\t\tAccept: 'application/json',\n\t\t\t\tAuthorization: `Bearer ${token}`,\n\t\t\t\t'Content-Type': 'application/json'\n\t\t\t},\n\t\t\tbody: JSON.stringify({\n\t\t\t\turl,\n\t\t\t\tkey\n\t\t\t})\n\t\t})\n\t\t\t.then(async (res) => {\n\t\t\t\tif (!res.ok) throw await res.json();\n\t\t\t\treturn res.json();\n\t\t\t})\n\t\t\t.catch((err) => {\n\t\t\t\terror = `OpenAI: ${err?.error?.message ?? 'Network Problem'}`;\n\t\t\t\treturn [];\n\t\t\t});\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\treturn res;\n};\n\nexport const chatCompletion = async (\n\ttoken: string = '',\n\tbody: object,\n\turl: string = `${WEBUI_BASE_URL}/api`\n): Promise<[Response | null, AbortController]> => {\n\tconst controller = new AbortController();\n\tlet error = null;\n\n\tconst res = await fetch(`${url}/chat/completions`, {\n\t\tsignal: controller.signal,\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAuthorization: `Bearer ${token}`,\n\t\t\t'Content-Type': 'application/json'\n\t\t},\n\t\tbody: JSON.stringify(body)\n\t}).catch((err) => {\n\t\tconsole.log(err);\n\t\terror = err;\n\t\treturn null;\n\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn [res, controller];\n};\n\nexport const generateOpenAIChatCompletion = async (\n\ttoken: string = '',\n\tbody: object,\n\turl: string = `${WEBUI_BASE_URL}/api`\n) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${url}/chat/completions`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAuthorization: `Bearer ${token}`,\n\t\t\t'Content-Type': 'application/json'\n\t\t},\n\t\tbody: JSON.stringify(body)\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\terror = `${err?.detail ?? err}`;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const synthesizeOpenAISpeech = async (\n\ttoken: string = '',\n\tspeaker: string = 'alloy',\n\ttext: string = '',\n\tmodel: string = 'tts-1'\n) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${OPENAI_API_BASE_URL}/audio/speech`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAuthorization: `Bearer ${token}`,\n\t\t\t'Content-Type': 'application/json'\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\tmodel: model,\n\t\t\tinput: text,\n\t\t\tvoice: speaker\n\t\t})\n\t}).catch((err) => {\n\t\tconsole.log(err);\n\t\terror = err;\n\t\treturn null;\n\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const addKneronDevice = async (token: string = '', device_ip: string = '') => {\n\tlet error = null;\n\n\tconst res = await fetch(`${OPENAI_API_BASE_URL}/lb_add_device`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAuthorization: `Bearer ${token}`,\n\t\t\t'Content-Type': 'application/json'\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\tdevice_ip: device_ip\n\t\t})\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\terror = `${err?.detail ?? err}`;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const getKneronDevices = async (token: string = '') => {\n\tlet error = null;\n\n\tconst res = await fetch(`${OPENAI_API_BASE_URL}/lb_get_devices`, {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\tAuthorization: `Bearer ${token}`,\n\t\t\t'Content-Type': 'application/json'\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\terror = `${err?.detail ?? err}`;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n","import { WEBUI_API_BASE_URL, WEBUI_BASE_URL } from '$lib/constants';\nimport { getOpenAIModelsDirect } from './openai';\n\nexport const getModels = async (\n\ttoken: string = '',\n\tconnections: object | null = null,\n\tbase: boolean = false\n) => {\n\tlet error = null;\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/models${base ? '/base' : ''}`, {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\terror = err;\n\t\t\tconsole.log(err);\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\tlet models = res?.data ?? [];\n\n\tif (connections && !base) {\n\t\tlet localModels = [];\n\n\t\tif (connections) {\n\t\t\tconst OPENAI_API_BASE_URLS = connections.OPENAI_API_BASE_URLS;\n\t\t\tconst OPENAI_API_KEYS = connections.OPENAI_API_KEYS;\n\t\t\tconst OPENAI_API_CONFIGS = connections.OPENAI_API_CONFIGS;\n\n\t\t\tconst requests = [];\n\t\t\tfor (const idx in OPENAI_API_BASE_URLS) {\n\t\t\t\tconst url = OPENAI_API_BASE_URLS[idx];\n\n\t\t\t\tif (idx.toString() in OPENAI_API_CONFIGS) {\n\t\t\t\t\tconst apiConfig = OPENAI_API_CONFIGS[idx.toString()] ?? {};\n\n\t\t\t\t\tconst enable = apiConfig?.enable ?? true;\n\t\t\t\t\tconst modelIds = apiConfig?.model_ids ?? [];\n\n\t\t\t\t\tif (enable) {\n\t\t\t\t\t\tif (modelIds.length > 0) {\n\t\t\t\t\t\t\tconst modelList = {\n\t\t\t\t\t\t\t\tobject: 'list',\n\t\t\t\t\t\t\t\tdata: modelIds.map((modelId) => ({\n\t\t\t\t\t\t\t\t\tid: modelId,\n\t\t\t\t\t\t\t\t\tname: modelId,\n\t\t\t\t\t\t\t\t\towned_by: 'openai',\n\t\t\t\t\t\t\t\t\topenai: { id: modelId },\n\t\t\t\t\t\t\t\t\turlIdx: idx\n\t\t\t\t\t\t\t\t}))\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\trequests.push(\n\t\t\t\t\t\t\t\t(async () => {\n\t\t\t\t\t\t\t\t\treturn modelList;\n\t\t\t\t\t\t\t\t})()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trequests.push(\n\t\t\t\t\t\t\t\t(async () => {\n\t\t\t\t\t\t\t\t\treturn await getOpenAIModelsDirect(url, OPENAI_API_KEYS[idx])\n\t\t\t\t\t\t\t\t\t\t.then((res) => {\n\t\t\t\t\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t.catch((err) => {\n\t\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\t\tobject: 'list',\n\t\t\t\t\t\t\t\t\t\t\t\tdata: [],\n\t\t\t\t\t\t\t\t\t\t\t\turlIdx: idx\n\t\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t})()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\trequests.push(\n\t\t\t\t\t\t\t(async () => {\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tobject: 'list',\n\t\t\t\t\t\t\t\t\tdata: [],\n\t\t\t\t\t\t\t\t\turlIdx: idx\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t})()\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst responses = await Promise.all(requests);\n\n\t\t\tfor (const idx in responses) {\n\t\t\t\tconst response = responses[idx];\n\t\t\t\tconst apiConfig = OPENAI_API_CONFIGS[idx.toString()] ?? {};\n\n\t\t\t\tlet models = Array.isArray(response) ? response : (response?.data ?? []);\n\t\t\t\tmodels = models.map((model) => ({ ...model, openai: { id: model.id }, urlIdx: idx }));\n\n\t\t\t\tconst prefixId = apiConfig.prefix_id;\n\t\t\t\tif (prefixId) {\n\t\t\t\t\tfor (const model of models) {\n\t\t\t\t\t\tmodel.id = `${prefixId}.${model.id}`;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlocalModels = localModels.concat(models);\n\t\t\t}\n\t\t}\n\n\t\tmodels = models.concat(\n\t\t\tlocalModels.map((model) => ({\n\t\t\t\t...model,\n\t\t\t\tname: model?.name ?? model?.id,\n\t\t\t\tdirect: true\n\t\t\t}))\n\t\t);\n\n\t\t// Remove duplicates\n\t\tconst modelsMap = {};\n\t\tfor (const model of models) {\n\t\t\tmodelsMap[model.id] = model;\n\t\t}\n\n\t\tmodels = Object.values(modelsMap);\n\t}\n\n\treturn models;\n};\n\ntype ChatCompletedForm = {\n\tmodel: string;\n\tmessages: string[];\n\tchat_id: string;\n\tsession_id: string;\n};\n\nexport const chatCompleted = async (token: string, body: ChatCompletedForm) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/chat/completed`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t},\n\t\tbody: JSON.stringify(body)\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t} else {\n\t\t\t\terror = err;\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\ntype ChatActionForm = {\n\tmodel: string;\n\tmessages: string[];\n\tchat_id: string;\n};\n\nexport const chatAction = async (token: string, action_id: string, body: ChatActionForm) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/chat/actions/${action_id}`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t},\n\t\tbody: JSON.stringify(body)\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t} else {\n\t\t\t\terror = err;\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const stopTask = async (token: string, id: string) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/tasks/stop/${id}`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t} else {\n\t\t\t\terror = err;\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const getTaskConfig = async (token: string = '') => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/v1/tasks/config`, {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\terror = err;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const updateTaskConfig = async (token: string, config: object) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/v1/tasks/config/update`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t},\n\t\tbody: JSON.stringify(config)\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t} else {\n\t\t\t\terror = err;\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const generateTitle = async (\n\ttoken: string = '',\n\tmodel: string,\n\tmessages: string[],\n\tchat_id?: string\n) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/v1/tasks/title/completions`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${token}`\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\tmodel: model,\n\t\t\tmessages: messages,\n\t\t\t...(chat_id && { chat_id: chat_id })\n\t\t})\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res?.choices[0]?.message?.content.replace(/[\"']/g, '') ?? 'New Chat';\n};\n\nexport const generateTags = async (\n\ttoken: string = '',\n\tmodel: string,\n\tmessages: string,\n\tchat_id?: string\n) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/v1/tasks/tags/completions`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${token}`\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\tmodel: model,\n\t\t\tmessages: messages,\n\t\t\t...(chat_id && { chat_id: chat_id })\n\t\t})\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\ttry {\n\t\t// Step 1: Safely extract the response string\n\t\tconst response = res?.choices[0]?.message?.content ?? '';\n\n\t\t// Step 2: Attempt to fix common JSON format issues like single quotes\n\t\tconst sanitizedResponse = response.replace(/['‘’`]/g, '\"'); // Convert single quotes to double quotes for valid JSON\n\n\t\t// Step 3: Find the relevant JSON block within the response\n\t\tconst jsonStartIndex = sanitizedResponse.indexOf('{');\n\t\tconst jsonEndIndex = sanitizedResponse.lastIndexOf('}');\n\n\t\t// Step 4: Check if we found a valid JSON block (with both `{` and `}`)\n\t\tif (jsonStartIndex !== -1 && jsonEndIndex !== -1) {\n\t\t\tconst jsonResponse = sanitizedResponse.substring(jsonStartIndex, jsonEndIndex + 1);\n\n\t\t\t// Step 5: Parse the JSON block\n\t\t\tconst parsed = JSON.parse(jsonResponse);\n\n\t\t\t// Step 6: If there's a \"tags\" key, return the tags array; otherwise, return an empty array\n\t\t\tif (parsed && parsed.tags) {\n\t\t\t\treturn Array.isArray(parsed.tags) ? parsed.tags : [];\n\t\t\t} else {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t}\n\n\t\t// If no valid JSON block found, return an empty array\n\t\treturn [];\n\t} catch (e) {\n\t\t// Catch and safely return empty array on any parsing errors\n\t\tconsole.error('Failed to parse response: ', e);\n\t\treturn [];\n\t}\n};\n\nexport const generateEmoji = async (\n\ttoken: string = '',\n\tmodel: string,\n\tprompt: string,\n\tchat_id?: string\n) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/v1/tasks/emoji/completions`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${token}`\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\tmodel: model,\n\t\t\tprompt: prompt,\n\t\t\t...(chat_id && { chat_id: chat_id })\n\t\t})\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\tconst response = res?.choices[0]?.message?.content.replace(/[\"']/g, '') ?? null;\n\n\tif (response) {\n\t\tif (/\\p{Extended_Pictographic}/u.test(response)) {\n\t\t\treturn response.match(/\\p{Extended_Pictographic}/gu)[0];\n\t\t}\n\t}\n\n\treturn null;\n};\n\nexport const generateQueries = async (\n\ttoken: string = '',\n\tmodel: string,\n\tmessages: object[],\n\tprompt: string,\n\ttype?: string = 'web_search'\n) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/v1/tasks/queries/completions`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${token}`\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\tmodel: model,\n\t\t\tmessages: messages,\n\t\t\tprompt: prompt,\n\t\t\ttype: type\n\t\t})\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\t// Step 1: Safely extract the response string\n\tconst response = res?.choices[0]?.message?.content ?? '';\n\n\ttry {\n\t\tconst jsonStartIndex = response.indexOf('{');\n\t\tconst jsonEndIndex = response.lastIndexOf('}');\n\n\t\tif (jsonStartIndex !== -1 && jsonEndIndex !== -1) {\n\t\t\tconst jsonResponse = response.substring(jsonStartIndex, jsonEndIndex + 1);\n\n\t\t\t// Step 5: Parse the JSON block\n\t\t\tconst parsed = JSON.parse(jsonResponse);\n\n\t\t\t// Step 6: If there's a \"queries\" key, return the queries array; otherwise, return an empty array\n\t\t\tif (parsed && parsed.queries) {\n\t\t\t\treturn Array.isArray(parsed.queries) ? parsed.queries : [];\n\t\t\t} else {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t}\n\n\t\t// If no valid JSON block found, return response as is\n\t\treturn [response];\n\t} catch (e) {\n\t\t// Catch and safely return empty array on any parsing errors\n\t\tconsole.error('Failed to parse response: ', e);\n\t\treturn [response];\n\t}\n};\n\nexport const generateAutoCompletion = async (\n\ttoken: string = '',\n\tmodel: string,\n\tprompt: string,\n\tmessages?: object[],\n\ttype: string = 'search query'\n) => {\n\tconst controller = new AbortController();\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/v1/tasks/auto/completions`, {\n\t\tsignal: controller.signal,\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${token}`\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\tmodel: model,\n\t\t\tprompt: prompt,\n\t\t\t...(messages && { messages: messages }),\n\t\t\ttype: type,\n\t\t\tstream: false\n\t\t})\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\tconst response = res?.choices[0]?.message?.content ?? '';\n\n\ttry {\n\t\tconst jsonStartIndex = response.indexOf('{');\n\t\tconst jsonEndIndex = response.lastIndexOf('}');\n\n\t\tif (jsonStartIndex !== -1 && jsonEndIndex !== -1) {\n\t\t\tconst jsonResponse = response.substring(jsonStartIndex, jsonEndIndex + 1);\n\n\t\t\t// Step 5: Parse the JSON block\n\t\t\tconst parsed = JSON.parse(jsonResponse);\n\n\t\t\t// Step 6: If there's a \"queries\" key, return the queries array; otherwise, return an empty array\n\t\t\tif (parsed && parsed.text) {\n\t\t\t\treturn parsed.text;\n\t\t\t} else {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t}\n\n\t\t// If no valid JSON block found, return response as is\n\t\treturn response;\n\t} catch (e) {\n\t\t// Catch and safely return empty array on any parsing errors\n\t\tconsole.error('Failed to parse response: ', e);\n\t\treturn response;\n\t}\n};\n\nexport const generateMoACompletion = async (\n\ttoken: string = '',\n\tmodel: string,\n\tprompt: string,\n\tresponses: string[]\n) => {\n\tconst controller = new AbortController();\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/v1/tasks/moa/completions`, {\n\t\tsignal: controller.signal,\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${token}`\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\tmodel: model,\n\t\t\tprompt: prompt,\n\t\t\tresponses: responses,\n\t\t\tstream: true\n\t\t})\n\t}).catch((err) => {\n\t\tconsole.log(err);\n\t\terror = err;\n\t\treturn null;\n\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn [res, controller];\n};\n\nexport const getPipelinesList = async (token: string = '') => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/v1/pipelines/list`, {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\terror = err;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\tlet pipelines = res?.data ?? [];\n\treturn pipelines;\n};\n\nexport const uploadPipeline = async (token: string, file: File, urlIdx: string) => {\n\tlet error = null;\n\n\t// Create a new FormData object to handle the file upload\n\tconst formData = new FormData();\n\tformData.append('file', file);\n\tformData.append('urlIdx', urlIdx);\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/v1/pipelines/upload`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t\t// 'Content-Type': 'multipart/form-data' is not needed as Fetch API will set it automatically\n\t\t},\n\t\tbody: formData\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t} else {\n\t\t\t\terror = err;\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const downloadPipeline = async (token: string, url: string, urlIdx: string) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/v1/pipelines/add`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\turl: url,\n\t\t\turlIdx: urlIdx\n\t\t})\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t} else {\n\t\t\t\terror = err;\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const deletePipeline = async (token: string, id: string, urlIdx: string) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/v1/pipelines/delete`, {\n\t\tmethod: 'DELETE',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\tid: id,\n\t\t\turlIdx: urlIdx\n\t\t})\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t} else {\n\t\t\t\terror = err;\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const getPipelines = async (token: string, urlIdx?: string) => {\n\tlet error = null;\n\n\tconst searchParams = new URLSearchParams();\n\tif (urlIdx !== undefined) {\n\t\tsearchParams.append('urlIdx', urlIdx);\n\t}\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/v1/pipelines/?${searchParams.toString()}`, {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\terror = err;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\tlet pipelines = res?.data ?? [];\n\treturn pipelines;\n};\n\nexport const getPipelineValves = async (token: string, pipeline_id: string, urlIdx: string) => {\n\tlet error = null;\n\n\tconst searchParams = new URLSearchParams();\n\tif (urlIdx !== undefined) {\n\t\tsearchParams.append('urlIdx', urlIdx);\n\t}\n\n\tconst res = await fetch(\n\t\t`${WEBUI_BASE_URL}/api/v1/pipelines/${pipeline_id}/valves?${searchParams.toString()}`,\n\t\t{\n\t\t\tmethod: 'GET',\n\t\t\theaders: {\n\t\t\t\tAccept: 'application/json',\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t\t}\n\t\t}\n\t)\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\terror = err;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const getPipelineValvesSpec = async (token: string, pipeline_id: string, urlIdx: string) => {\n\tlet error = null;\n\n\tconst searchParams = new URLSearchParams();\n\tif (urlIdx !== undefined) {\n\t\tsearchParams.append('urlIdx', urlIdx);\n\t}\n\n\tconst res = await fetch(\n\t\t`${WEBUI_BASE_URL}/api/v1/pipelines/${pipeline_id}/valves/spec?${searchParams.toString()}`,\n\t\t{\n\t\t\tmethod: 'GET',\n\t\t\theaders: {\n\t\t\t\tAccept: 'application/json',\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t\t}\n\t\t}\n\t)\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\terror = err;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const updatePipelineValves = async (\n\ttoken: string = '',\n\tpipeline_id: string,\n\tvalves: object,\n\turlIdx: string\n) => {\n\tlet error = null;\n\n\tconst searchParams = new URLSearchParams();\n\tif (urlIdx !== undefined) {\n\t\tsearchParams.append('urlIdx', urlIdx);\n\t}\n\n\tconst res = await fetch(\n\t\t`${WEBUI_BASE_URL}/api/v1/pipelines/${pipeline_id}/valves/update?${searchParams.toString()}`,\n\t\t{\n\t\t\tmethod: 'POST',\n\t\t\theaders: {\n\t\t\t\tAccept: 'application/json',\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t\t},\n\t\t\tbody: JSON.stringify(valves)\n\t\t}\n\t)\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t} else {\n\t\t\t\terror = err;\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const getBackendConfig = async () => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/config`, {\n\t\tmethod: 'GET',\n\t\tcredentials: 'omit',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json'\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\terror = err;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const getChangelog = async () => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/changelog`, {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json'\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\terror = err;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const getVersionUpdates = async (token: string) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/version/updates`, {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${token}`\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\terror = err;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const getModelFilterConfig = async (token: string) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/config/model/filter`, {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${token}`\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\terror = err;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const updateModelFilterConfig = async (\n\ttoken: string,\n\tenabled: boolean,\n\tmodels: string[]\n) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/config/model/filter`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${token}`\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\tenabled: enabled,\n\t\t\tmodels: models\n\t\t})\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\terror = err;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const getWebhookUrl = async (token: string) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/webhook`, {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${token}`\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\terror = err;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res.url;\n};\n\nexport const updateWebhookUrl = async (token: string, url: string) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/webhook`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${token}`\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\turl: url\n\t\t})\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\terror = err;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res.url;\n};\n\nexport const getCommunitySharingEnabledStatus = async (token: string) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/community_sharing`, {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${token}`\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\terror = err;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const toggleCommunitySharingEnabledStatus = async (token: string) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/community_sharing/toggle`, {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${token}`\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\terror = err.detail;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const getModelConfig = async (token: string): Promise<GlobalModelConfig> => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/config/models`, {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${token}`\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\terror = err;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res.models;\n};\n\nexport interface ModelConfig {\n\tid: string;\n\tname: string;\n\tmeta: ModelMeta;\n\tbase_model_id?: string;\n\tparams: ModelParams;\n}\n\nexport interface ModelMeta {\n\tdescription?: string;\n\tcapabilities?: object;\n\tprofile_image_url?: string;\n}\n\nexport interface ModelParams {}\n\nexport type GlobalModelConfig = ModelConfig[];\n\nexport const updateModelConfig = async (token: string, config: GlobalModelConfig) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/config/models`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${token}`\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\tmodels: config\n\t\t})\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.log(err);\n\t\t\terror = err;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n"],"names":["res","models"],"mappings":"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"}