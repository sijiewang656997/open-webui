{"version":3,"file":"scheduler.js","sources":["../../../../node_modules/svelte/src/runtime/internal/scheduler.js"],"sourcesContent":["import { run_all } from './utils.js';\nimport { current_component, set_current_component } from './lifecycle.js';\n\nexport const dirty_components = [];\nexport const intros = { enabled: false };\nexport const binding_callbacks = [];\n\nlet render_callbacks = [];\n\nconst flush_callbacks = [];\n\nconst resolved_promise = /* @__PURE__ */ Promise.resolve();\n\nlet update_scheduled = false;\n\n/** @returns {void} */\nexport function schedule_update() {\n\tif (!update_scheduled) {\n\t\tupdate_scheduled = true;\n\t\tresolved_promise.then(flush);\n\t}\n}\n\n/** @returns {Promise<void>} */\nexport function tick() {\n\tschedule_update();\n\treturn resolved_promise;\n}\n\n/** @returns {void} */\nexport function add_render_callback(fn) {\n\trender_callbacks.push(fn);\n}\n\n/** @returns {void} */\nexport function add_flush_callback(fn) {\n\tflush_callbacks.push(fn);\n}\n\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\n\nlet flushidx = 0; // Do *not* move this inside the flush() function\n\n/** @returns {void} */\nexport function flush() {\n\t// Do not reenter flush while dirty components are updated, as this can\n\t// result in an infinite loop. Instead, let the inner flush handle it.\n\t// Reentrancy is ok afterwards for bindings etc.\n\tif (flushidx !== 0) {\n\t\treturn;\n\t}\n\tconst saved_component = current_component;\n\tdo {\n\t\t// first, call beforeUpdate functions\n\t\t// and update components\n\t\ttry {\n\t\t\twhile (flushidx < dirty_components.length) {\n\t\t\t\tconst component = dirty_components[flushidx];\n\t\t\t\tflushidx++;\n\t\t\t\tset_current_component(component);\n\t\t\t\tupdate(component.$$);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// reset dirty state to not end up in a deadlocked state and then rethrow\n\t\t\tdirty_components.length = 0;\n\t\t\tflushidx = 0;\n\t\t\tthrow e;\n\t\t}\n\t\tset_current_component(null);\n\t\tdirty_components.length = 0;\n\t\tflushidx = 0;\n\t\twhile (binding_callbacks.length) binding_callbacks.pop()();\n\t\t// then, once components are updated, call\n\t\t// afterUpdate functions. This may cause\n\t\t// subsequent updates...\n\t\tfor (let i = 0; i < render_callbacks.length; i += 1) {\n\t\t\tconst callback = render_callbacks[i];\n\t\t\tif (!seen_callbacks.has(callback)) {\n\t\t\t\t// ...so guard against infinite loops\n\t\t\t\tseen_callbacks.add(callback);\n\t\t\t\tcallback();\n\t\t\t}\n\t\t}\n\t\trender_callbacks.length = 0;\n\t} while (dirty_components.length);\n\twhile (flush_callbacks.length) {\n\t\tflush_callbacks.pop()();\n\t}\n\tupdate_scheduled = false;\n\tseen_callbacks.clear();\n\tset_current_component(saved_component);\n}\n\n/** @returns {void} */\nfunction update($$) {\n\tif ($$.fragment !== null) {\n\t\t$$.update();\n\t\trun_all($$.before_update);\n\t\tconst dirty = $$.dirty;\n\t\t$$.dirty = [-1];\n\t\t$$.fragment && $$.fragment.p($$.ctx, dirty);\n\t\t$$.after_update.forEach(add_render_callback);\n\t}\n}\n\n/**\n * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.\n * @param {Function[]} fns\n * @returns {void}\n */\nexport function flush_render_callbacks(fns) {\n\tconst filtered = [];\n\tconst targets = [];\n\trender_callbacks.forEach((c) => (fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c)));\n\ttargets.forEach((c) => c());\n\trender_callbacks = filtered;\n}\n"],"names":[],"mappings":";AAGO,MAAM,mBAAmB,CAAA;AAEzB,MAAM,oBAAoB,CAAA;AAEjC,IAAI,mBAAmB,CAAA;AAEvB,MAAM,kBAAkB,CAAA;AAExB,MAAM,mBAAmC,wBAAQ;AAEjD,IAAI,mBAAmB;AAGhB,SAAS,kBAAkB;AACjC,MAAI,CAAC,kBAAkB;AACtB,uBAAmB;AACnB,qBAAiB,KAAK,KAAK;AAAA,EAC3B;AACF;AAGO,SAAS,OAAO;AACtB;AACA,SAAO;AACR;AAGO,SAAS,oBAAoB,IAAI;AACvC,mBAAiB,KAAK,EAAE;AACzB;AAyBA,MAAM,iBAAiB,oBAAI;AAE3B,IAAI,WAAW;AAGR,SAAS,QAAQ;AAIvB,MAAI,aAAa,GAAG;AACnB;AAAA,EACA;AACD,QAAM,kBAAkB;AACxB,KAAG;AAGF,QAAI;AACH,aAAO,WAAW,iBAAiB,QAAQ;AAC1C,cAAM,YAAY,iBAAiB,QAAQ;AAC3C;AACA,8BAAsB,SAAS;AAC/B,eAAO,UAAU,EAAE;AAAA,MACnB;AAAA,IACD,SAAQ,GAAG;AAEX,uBAAiB,SAAS;AAC1B,iBAAW;AACX,YAAM;AAAA,IACN;AACD,0BAAsB,IAAI;AAC1B,qBAAiB,SAAS;AAC1B,eAAW;AACX,WAAO,kBAAkB,OAAQ,mBAAkB,IAAK,EAAA;AAIxD,aAAS,IAAI,GAAG,IAAI,iBAAiB,QAAQ,KAAK,GAAG;AACpD,YAAM,WAAW,iBAAiB,CAAC;AACnC,UAAI,CAAC,eAAe,IAAI,QAAQ,GAAG;AAElC,uBAAe,IAAI,QAAQ;AAC3B;MACA;AAAA,IACD;AACD,qBAAiB,SAAS;AAAA,EAC5B,SAAU,iBAAiB;AAC1B,SAAO,gBAAgB,QAAQ;AAC9B,oBAAgB,IAAG;EACnB;AACD,qBAAmB;AACnB,iBAAe,MAAK;AACpB,wBAAsB,eAAe;AACtC;AAGA,SAAS,OAAO,IAAI;AACnB,MAAI,GAAG,aAAa,MAAM;AACzB,OAAG,OAAM;AACT,YAAQ,GAAG,aAAa;AACxB,UAAM,QAAQ,GAAG;AACjB,OAAG,QAAQ,CAAC,EAAE;AACd,OAAG,YAAY,GAAG,SAAS,EAAE,GAAG,KAAK,KAAK;AAC1C,OAAG,aAAa,QAAQ,mBAAmB;AAAA,EAC3C;AACF;","x_google_ignoreList":[0]}